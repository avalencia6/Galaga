#include "mbed.h"
#include "uLCD_4DGL.h"
#include "PinDetect.h"
#include "Speaker.h"
#include <cstdlib> 
#include <time.h> 
#include <iomanip>
#include <stdio.h> 

#define ALIEN_HEIGHT 8
#define ALIEN_WIDTH 13
#define _ 0x000000 //BLACK
#define X 0xFFFFFF //WHITE

DigitalOut myled1(LED1);
DigitalOut myled2(LED2);
DigitalOut myled3(LED3);

uLCD_4DGL uLCD(p9,p10,p11); // serial tx, serial rx, reset pin;
//Instantiate pins for pushbuttons
PinDetect pbLeft(p21); 
PinDetect pbRight(p22); 
PinDetect pbFire(p23); 
// setup instance of new Speaker class, mySpeaker using pin 18
Speaker mySpeaker(p18);
//instantiate a global Timer
Timer t;
//booleans for the interrupts
bool shipUpdateLeft = false;
bool shipUpdateRight = false;
bool shipFire = false;

using namespace std;

//---------------------------------------------------------------------------------------------------
// Callback routine is interrupt activated by a debounced pbLeft hit
// That is … this code runs with interrupt is generated by first button press
void pbLeft_hit_callback (void)
{ myled1 = !myled1;
  shipUpdateLeft = true;
}
//---------------------------------------------------------------------------------------------------
// Callback routine is interrupt activated by a debounced pbRight hit
// That is … this code runs with interrupt is generated by second button press
void pbRight_hit_callback (void)
{ myled2 = !myled2;
  shipUpdateRight = true;
}
//---------------------------------------------------------------------------------------------------
// Callback routine is interrupt activated by a debounced pbFire hit
// That is … this code runs with interrupt is generated by third button press
void pbFire_hit_callback (void)
{ myled3 = !myled3;
  shipFire = true;
}





using namespace std;


////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//The following is the polymorphic heirarchy of ScreenAlien classes-----------------------------------------
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
class ScreenAliens {
    private:   
        int xPos, yPos;    
    public: 
        virtual void draw() = 0;
        virtual void update() = 0;
        int getXpos(){
            return xPos;
        }
        void setXpos(int x){
            xPos = x;
        }
        int getYpos(){
            return yPos;
        }
        void setYpos(int y){
            yPos = y;
        }
        void clear(int clr[104]){
            uLCD.BLIT(xPos, yPos, ALIEN_WIDTH, ALIEN_HEIGHT, clr);
        }
}; // end abstract class ScreenAliens 





class AlienBob : public ScreenAliens{
    private:
        int upSprite[104];
        int downSprite[104];
        bool displayDown;
        int direction; //left = 0, right = 1
    public:
        AlienBob(int upSpr[104], int downSpr[104], int xInit, int row){
            displayDown = true;
            direction = 1;
            setXpos(xInit);
            for (int i = 0; i < 104; i++){
                upSprite[i] = upSpr[i];
            }
            for (int i = 0; i < 104; i++){
                downSprite[i] = downSpr[i];
            }
            setYpos(10 + (2* row) + (8 * row));
        }
        void draw(){
            if (getXpos()%8 == 0){
                displayDown = !displayDown;
            }
            if (displayDown){
                uLCD.BLIT(getXpos(), getYpos(), ALIEN_WIDTH, ALIEN_HEIGHT, downSprite);
            }
            else{
                uLCD.BLIT(getXpos(), getYpos(), ALIEN_WIDTH, ALIEN_HEIGHT, upSprite);
            }
        }
        void update(){//this version of update makes the aliens go from end-to-end
            if (direction && getXpos() < 128 - ALIEN_WIDTH){
                int current = getXpos();
                setXpos(current + 1);
            }//going right @ space case
            if (direction && getXpos() == 128 - ALIEN_WIDTH){
                direction = 0;
                int current = getXpos();
                setXpos(current - 1);
            }//going right @ edge case
            if (!direction && getXpos() > 1){
                int current = getXpos();
                setXpos(current - 1);
            }//going left @ space case
            if (!direction && getXpos() == 1){
                direction = 1;
                int current = getXpos();
                setXpos(current + 1);
            }//going left @ edge case
        }
};//end class AlienBob




class AlienAlice : public ScreenAliens{
    private:
        int Sprite[104];
        int direction; //left = 0, right = 1
    public:
        AlienAlice(int Spr[104], int xInit, int row){
            direction = 1;
            setXpos(xInit);
            for (int i = 0; i < 104; i++){
                Sprite[i] = Spr[i];
            }
            setYpos(10 + (2* row) + (8 * row));
        }
        void draw(){
                uLCD.BLIT(getXpos(), getYpos(), ALIEN_WIDTH, ALIEN_HEIGHT, Sprite);
            }
        void update(){
            //this version of update makes the aliens go from end-to-end
            if (direction && getXpos() < 128 - ALIEN_WIDTH){
                int current = getXpos();
                setXpos(current + 2);
            }//going right @ space case
            if (direction && getXpos() >= 128 - ALIEN_WIDTH){
                direction = 0;
                int current = getXpos();
                setXpos(current - 2);
            }//going right @ edge case
            if (!direction && getXpos() > 1){
                int current = getXpos();
                setXpos(current - 2);
            }//going left @ space case
            if (!direction && getXpos() <= 1){
                direction = 1;
                int current = getXpos();
                setXpos(current + 2);
            }//going left @ edge case
        }
};//end class AlienAlice 




class AlienMorty : public ScreenAliens{
    private:
        int Sprite[104];
        int direction; //left = 0, right = 1
    public:
        AlienMorty(int Spr[104], int xInit, int row){
            direction = 1;
            setXpos(xInit);
            for (int i = 0; i < 104; i++){
                Sprite[i] = Spr[i];
            }
            setYpos(10 + (2* row) + (8 * row));
        }
        void draw(){
                uLCD.BLIT(getXpos(), getYpos(), ALIEN_WIDTH, ALIEN_HEIGHT, Sprite);
            }
        void update(){
            //this version of update makes the aliens go from end-to-end
            if (direction && getXpos() < 128 - ALIEN_WIDTH){
                int current = getXpos();
                setXpos(current + 1);
            }//going right @ space case
            if (direction && getXpos() >= 128 - ALIEN_WIDTH){
                direction = 0;
                int current = getXpos();
                setXpos(current - 1);
            }//going right @ edge case
            if (!direction && getXpos() > 1){
                int current = getXpos();
                setXpos(current - 1);
            }//going left @ space case
            if (!direction && getXpos() <= 1){
                direction = 1;
                int current = getXpos();
                setXpos(current + 1);
            }//going left @ edge case
        }
};//end class AlienMorty





class AlienRick : public ScreenAliens{
    private:
        int inSprite[104];
        int outSprite[104];
        bool displayOut;
        int direction; //left = 0, right = 1
    public:
        AlienRick(int inSpr[104], int outSpr[104], int xInit, int row){
            displayOut = true;
            direction = 1;
            setXpos(xInit);
            for (int i = 0; i < 104; i++){
                inSprite[i] = inSpr[i];
            }
            for (int i = 0; i < 104; i++){
                outSprite[i] = outSpr[i];
            }
            setYpos(10 + (2* row) + (8 * row));
        }
        void draw(){
            if (getXpos()%8 == 0){
                displayOut = !displayOut;
            }
            if (displayOut){
                uLCD.BLIT(getXpos(), getYpos(), ALIEN_WIDTH, ALIEN_HEIGHT, outSprite);
            }
            else{
                uLCD.BLIT(getXpos(), getYpos(), ALIEN_WIDTH, ALIEN_HEIGHT, inSprite);
            }
        }
        void update(){//this version of update makes the aliens go from end-to-end
            if (direction && getXpos() < 128 - ALIEN_WIDTH){
                int current = getXpos();
                setXpos(current + 1);
            }//going right @ space case
            if (direction && getXpos() == 128 - ALIEN_WIDTH){
                direction = 0;
                int current = getXpos();
                setXpos(current - 1);
            }//going right @ edge case
            if (!direction && getXpos() > 1){
                int current = getXpos();
                setXpos(current - 1);
            }//going left @ space case
            if (!direction && getXpos() == 1){
                direction = 1;
                int current = getXpos();
                setXpos(current + 1);
            }//going left @ edge case
        }
};//end class AlienRick





////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//The following is the class for the spaceship the player controls------------------------------------------
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
class battleShip{
    private:
        int Sprite[264];   
        int xPos;
        int yPos; 
    public:
        battleShip(){
            for (int i = 0; i < 264; i++){
                Sprite[i] = X;
            }
        xPos = 0;
        yPos = 0;
        }
        battleShip(int Spr[264]){
            xPos = 44;
            for (int i = 0; i < 264; i++){
                Sprite[i] = Spr[i];
            }
            yPos = 119;
        }
        void draw(){
            uLCD.BLIT(xPos, yPos, ALIEN_WIDTH + 20, ALIEN_HEIGHT, Sprite);
        }
        void update(int changeInX){
            xPos = xPos + changeInX;
        }
        int getXpos(){
            return xPos;
        }
        int getYpos(){
            return yPos;
        }
};//end class battleShip




////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//The following is the class for the bullets the player shoots from the spaceship---------------------------
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
class bullet{
    private:
        int Sprite[44];
        int clearSpr[44];
        int xbPos;
        int ybPos;   
        bool present;
    public:
        bullet(){
            for (int i = 0; i < 44; i++){
                Sprite[i] = X;
            }
            for (int i = 0; i < 44; i++){
                clearSpr[i] = _;
            }
            xbPos = 0;
            ybPos = 0;
            present = false;
        }
        bullet(int Spr[44]){
            xbPos = 0;
            for (int i = 0; i < 44; i++){
                Sprite[i] = Spr[i];
            }
            for (int i = 0; i < 44; i++){
                clearSpr[i] = _;
            }
            ybPos = 108;
            present = false;
        }
        void draw(int shipPos){
            xbPos = shipPos + 14;
            ybPos = 108;
            uLCD.BLIT(xbPos, ybPos, ALIEN_WIDTH - 9, ALIEN_HEIGHT + 3, Sprite);
            present = true;
        }
        void draw(){
            uLCD.BLIT(xbPos, ybPos, ALIEN_WIDTH - 9, ALIEN_HEIGHT + 3, Sprite);
            present = true;
        }
        void update(){
            ybPos = ybPos - 3;
            if (ybPos <= 3) {
                uLCD.BLIT(xbPos, ybPos, ALIEN_WIDTH - 9, ALIEN_HEIGHT + 3, clearSpr);
                xbPos = 0;
                present = false;
            }
        }
        bool isPresent(){
            return present;
        }
        int getXpos(){
            return xbPos;
        }
        int getYpos(){
            return ybPos;
        }
        void clear(){
            uLCD.BLIT(xbPos, ybPos, ALIEN_WIDTH - 9, ALIEN_HEIGHT + 3, clearSpr);
            xbPos = 0;
            present = false;
        }
};//end class bullet






////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//The following is the main program-------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
int main(){
    //change the pushbuttons' mode
    pbLeft.mode(PullUp);
    pbRight.mode(PullUp);
    pbFire.mode(PullUp);
    wait(0.1);//give it time to set the mode
    uLCD.baudrate(3000000);
    wait(0.2);
    // Setup Interrupt callback functions for a pb hit
    pbLeft.attach_deasserted(&pbLeft_hit_callback);
    pbRight.attach_deasserted(&pbRight_hit_callback);
    pbFire.attach_deasserted(&pbFire_hit_callback);
    // Start sampling pb inputs using interrupts
    pbLeft.setSampleFrequency();
    pbRight.setSampleFrequency();
    pbFire.setSampleFrequency();
    // pushbuttons now setup and running
    time_t seconds; //create a variable to hold the seconds on the mbed clock
    time(&seconds); //get value from systems clock and place it in seconds variable 
    srand((unsigned int) seconds); //convert seconds to an unsigned int before using it in srand 
    int battleShip_sprite[ALIEN_HEIGHT * (ALIEN_WIDTH + 20)] = {
        _,_,_,_,_,_,_,_,_,_,_,_,X,_,_,_,_,_,_,X,_,_,_,_,_,_,_,_,_,_,_,_,_,
        _,_,_,_,_,_,_,_,_,_,_,X,X,X,_,_,_,_,X,X,X,_,_,_,_,_,_,_,_,_,_,_,_,
        _,_,_,_,_,_,_,_,_,_,_,X,X,X,_,_,_,_,X,X,X,_,_,_,_,_,_,_,_,_,_,_,_,
        _,_,_,_,_,_,_,_,_,_,_,X,X,X,_,_,_,_,X,X,X,_,_,_,_,_,_,_,_,_,_,_,_,
        _,_,_,_,_,_,_,_,_,_,_,X,X,X,X,X,X,X,X,X,X,_,_,_,_,_,_,_,_,_,_,_,_,
        _,_,_,_,_,_,_,_,_,_,_,X,X,X,X,X,X,X,X,X,_,_,_,_,_,_,_,_,_,_,_,_,_,
        _,_,_,_,_,_,_,_,_,_,_,_,X,X,X,X,X,X,X,_,_,_,_,_,_,_,_,_,_,_,_,_,_,
        _,_,_,_,_,_,_,_,_,_,_,_,_,_,X,X,X,X,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,
    };
    int alienBobDown_sprite[ALIEN_HEIGHT * ALIEN_WIDTH] = {
        _,_,_,X,_,_,_,_,_,X,_,_,_,
        _,_,_,_,X,_,_,_,X,_,_,_,_,
        _,_,_,X,X,X,X,X,X,X,_,_,_,
        _,_,X,X,_,X,X,X,_,X,X,_,_,
        _,X,X,X,X,X,X,X,X,X,X,X,_,
        _,X,_,X,X,X,X,X,X,X,_,X,_,
        _,X,_,X,_,_,_,_,_,X,_,X,_,
        _,_,_,_,X,X,_,X,X,_,_,_,_,
    };
    int alienBobUp_sprite[ALIEN_HEIGHT * ALIEN_WIDTH] = {
        _,_,_,X,_,_,_,_,_,X,_,_,_,
        _,X,_,_,X,_,_,_,X,_,_,X,_,
        _,X,_,X,X,X,X,X,X,X,_,X,_,
        _,X,X,X,_,X,X,X,_,X,X,X,_,
        _,X,X,X,X,X,X,X,X,X,X,X,_,
        _,_,_,X,X,X,X,X,X,X,_,_,_,
        _,_,_,X,_,_,_,_,_,X,_,_,_,
        _,_,X,_,_,_,_,_,_,_,X,_,_,
    };
    int alienAlice_sprite[ALIEN_HEIGHT * ALIEN_WIDTH] = {
        _,_,_,_,_,X,X,X,_,_,_,_,_,
        _,_,X,X,X,X,X,X,X,X,X,_,_,
        _,_,X,X,X,X,X,X,X,X,X,_,_,
        _,_,X,X,_,_,X,_,_,X,X,_,_,
        _,_,X,X,X,X,X,X,X,X,X,_,_,
        _,_,_,_,X,X,_,X,X,_,_,_,_,
        _,_,_,X,X,_,_,_,X,X,_,_,_,
        _,_,X,_,_,_,X,_,_,_,X,_,_,
    };
    int alienRickOut_sprite[ALIEN_HEIGHT * ALIEN_WIDTH] = {
        _,_,X,X,X,_,_,_,X,X,X,_,_,
        _,_,_,_,X,_,_,_,X,_,_,_,_,
        _,_,_,X,X,X,X,X,X,X,_,_,_,
        _,_,X,X,_,X,X,X,_,X,X,_,_,
        _,X,X,X,X,X,X,X,X,X,X,X,_,
        _,X,X,X,X,_,_,_,X,X,X,X,_,
        _,X,X,X,_,X,X,X,_,X,X,X,_,
        _,_,_,_,X,X,X,X,X,_,_,_,_,
    };int alienRickIn_sprite[ALIEN_HEIGHT * ALIEN_WIDTH] = {
        _,_,_,_,_,X,X,X,_,_,_,_,_,
        _,_,_,_,X,_,_,_,X,_,_,_,_,
        _,_,_,X,X,X,X,X,X,X,_,_,_,
        _,_,X,X,_,X,X,X,_,X,X,_,_,
        _,X,X,X,X,X,X,X,X,X,X,X,_,
        _,X,X,X,X,_,_,_,X,X,X,X,_,
        _,X,X,X,_,X,X,X,_,X,X,X,_,
        _,_,_,_,X,X,X,X,X,_,_,_,_,
    };
    int alienMorty_sprite[ALIEN_HEIGHT * ALIEN_WIDTH] = {
        _,X,X,X,X,X,X,X,X,X,X,X,_,
        _,X,X,X,_,X,X,X,_,X,X,X,_,
        _,X,X,_,_,X,X,X,_,_,X,X,_,
        _,X,_,X,X,X,X,X,X,X,_,X,_,
        _,_,X,X,_,X,X,X,_,X,X,_,_,
        _,X,X,X,X,X,X,X,X,X,X,X,_,
        _,X,X,X,_,_,_,_,_,X,X,X,_,
        _,X,X,_,X,X,X,X,X,_,X,X,_,
    };
    int alienClear_sprite[ALIEN_HEIGHT * ALIEN_WIDTH] = {
        _,_,_,_,_,_,_,_,_,_,_,_,_,
        _,_,_,_,_,_,_,_,_,_,_,_,_,
        _,_,_,_,_,_,_,_,_,_,_,_,_,
        _,_,_,_,_,_,_,_,_,_,_,_,_,
        _,_,_,_,_,_,_,_,_,_,_,_,_,
        _,_,_,_,_,_,_,_,_,_,_,_,_,
        _,_,_,_,_,_,_,_,_,_,_,_,_,
        _,_,_,_,_,_,_,_,_,_,_,_,_,
    };
    int bullet_sprite[(ALIEN_HEIGHT + 3) * (ALIEN_WIDTH - 9)] = {
        X,X,X,X,
        X,X,X,X,
        X,X,X,X,
        X,X,X,X,
        X,X,X,X,
        X,X,X,X,
        X,X,X,X,
        X,X,X,X,
        _,_,_,_,
        _,_,_,_,
        _,_,_,_,
    };
    ScreenAliens * aliens[6];
    int i = 0;
    int numShots = 0; //used to store the total number of bullets fired, for the accuracy calculation
    int startingXpos = rand()%(128-ALIEN_WIDTH) + 1; 
    int alienType = rand()%4 + 1;//randomize the alien type
    while (i < 6){//this while loop populates the screen with ScreenAliens-class objects
        switch(alienType){
            case (1):
                aliens[i] = new AlienBob(alienBobUp_sprite, alienBobDown_sprite, startingXpos, i);
                (*aliens[i]).draw();
                startingXpos = rand()%(128-ALIEN_WIDTH) + 1;
                i++;
                break;
            case(2):
                aliens[i] = new AlienAlice(alienAlice_sprite, startingXpos, i);
                (*aliens[i]).draw();
                startingXpos = rand()%(128 - ALIEN_WIDTH) + 1;
                i++;
                break;
            case(3):
                aliens[i] = new AlienRick(alienRickOut_sprite, alienRickIn_sprite, startingXpos, i);
                (*aliens[i]).draw();
                startingXpos = rand()%(128 - ALIEN_WIDTH) + 1;
                i++;
                break;
            case(4): 
                aliens[i] = new AlienMorty(alienMorty_sprite, startingXpos, i);
                (*aliens[i]).draw();
                startingXpos = rand()%(128 - ALIEN_WIDTH) + 1;
                i++;
                break;
        }
        alienType = rand()%4 + 1;
    }
    battleShip Player(battleShip_sprite);
    Player.draw();
    bullet Bullet(bullet_sprite);
    int cleared[6] = {0, 0, 0, 0, 0, 0};
    wait(1.0);
    t.start();
    //after the timer starts, this while loop is the gameplay: the aliens continue to move until they are shot, and once all of the aliens are destroyed, the game ends
    //the game ends when this while loop is exited
    while (cleared[0] == 0 || cleared[1] == 0 || cleared[2] == 0 || cleared[3] == 0 || cleared[4] == 0 || cleared[5] == 0 ){
        for (int i = 0; i < 6; i++){
            if (cleared[i]  != 1){
                (*aliens[i]).update();
                (*aliens[i]).draw();
            }
        }
        if (shipUpdateLeft){
            Player.update(-10);
            shipUpdateLeft = !shipUpdateLeft;
            Player.draw();
        }
        else if(shipUpdateRight){
            Player.update(10);
            shipUpdateRight = !shipUpdateRight;
            Player.draw();
        }
        if (Bullet.isPresent()){
            Bullet.draw();
            Bullet.update();
        }
        if (shipFire && !Bullet.isPresent()){
            mySpeaker.PlayNote(200.0,0.1,1.0);
            Bullet.draw(Player.getXpos());
            numShots++;
            shipFire = !shipFire;
        }
        for (int i = 0; i < 6; i++){
            if (Bullet.isPresent() && cleared[i] == 0 && Bullet.getXpos() + 3 >= (*aliens[i]).getXpos() && Bullet.getXpos() - 3 <= (*aliens[i]).getXpos() + ALIEN_WIDTH && Bullet.getYpos() >= (*aliens[i]).getYpos() && Bullet.getYpos() + 3 <= (*aliens[i]).getYpos() + ALIEN_HEIGHT){
                (*aliens[i]).clear(alienClear_sprite);
                Bullet.clear();
                mySpeaker.PlayNote(800.0,0.1,1.0);
                cleared[i] = 1;
                continue;
            }
        }
        wait(0.01);
    }
    
    t.stop();
    uLCD.cls();//remove all graphics from the screen to display the results
    char a[5];
    strcpy(a, "%");
    uLCD.printf("\n \n \n Congratulations!! \n \n Earth Saved!!! \n \n \n \n Time: %1.2f sec \n \n Accuracy: %1.2f%s", double(t.read_ms())/double(1000), double(6)/double(numShots) * 100, a);
    //here's a winning jingle for part 3 of the requirements:
    mySpeaker.PlayNote(300.0,0.1,1.0);
    mySpeaker.PlayNote(500.0,0.1,1.0);
    mySpeaker.PlayNote(700.0,0.1,1.0);
    mySpeaker.PlayNote(800.0,0.2,1.0);
    mySpeaker.PlayNote(800.0,0.2,1.0);
    for (int i = 0; i < 6; i++){
       delete aliens[i];
    }//de-allocating memory to avoid memory leak
        
}//end main
